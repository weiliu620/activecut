#include <common.h>
#include <graph.h>
#include <gmm.h>
#include <utility.h>

int build_adjmat(ImageType3DI::Pointer parcelPtr,
		       const vnl_matrix <double> & data, 
		       vnl_sparse_matrix <double> & con_map,
		       ParType & par)
{
     ImageType3DI::SizeType parcelSize = parcelPtr->GetLargestPossibleRegion().GetSize();
     ImageType3DI::IndexType parcelIdx, nbr_idx;

     // find how many super-pixels. i.e. the max of the image.
     typedef itk::MinimumMaximumImageCalculator <ImageType3DI> ImageCalculatorFilterType;
     ImageCalculatorFilterType::Pointer imageCalculatorFilter = ImageCalculatorFilterType::New ();
     imageCalculatorFilter->SetImage(parcelPtr);
     imageCalculatorFilter->ComputeMaximum();

     unsigned n_samples = data.rows();
     con_map.set_size(n_samples, n_samples);

     // define neighborhood iterator
     typedef itk::ConstantBoundaryCondition<ImageType3DI>  BoundaryConditionType;
     typedef itk::NeighborhoodIterator< ImageType3DI, BoundaryConditionType > NeighborhoodIteratorType;
     NeighborhoodIteratorType::RadiusType radius;
     radius.Fill(1);
     NeighborhoodIteratorType parcelIt(radius, parcelPtr, parcelPtr->GetLargestPossibleRegion());
     unsigned int nei_set_array[] = {4, 10, 12, 14, 16, 22, // 6 neighborhood
				     1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25, // 18 neighborhood
				     0, 2, 6, 8, 18, 20, 24, 26}; // 26 neighborhood

     if (par.n_nbrs != 6 && par.n_nbrs != 18 && par.n_nbrs != 26) {
	  printf("graphcuts(): number of neighbors must be 6, 18, or 26. Other values may give inacruate results!\n");
	  if (par.n_nbrs > 26) {
	       printf("graphcuts(): number of neighbors at least need to be less than 26 in order for the algorithm to run!\n");
	       exit;
	  }
     }

     int cur_patch_id = 0, nbr_patch_id = 0;
     // if current voxel is boundary between patch i and j, add one on
     // con_map(i,j). 
     unsigned offset = 0;
     for (parcelIt.GoToBegin(); !parcelIt.IsAtEnd(); ++ parcelIt) {
	  if ( parcelIt.GetCenterPixel() > 0) {
	       cur_patch_id = parcelIt.GetCenterPixel() - 1;
	       
	       // debug: look for sample id given ijk
	       parcelIdx = parcelIt.GetIndex();
	       if (parcelIdx[0] == 192 && parcelIdx[1] == 141 && parcelIdx[2] == 2)
		    printf("sample id = %i\n", cur_patch_id);
	       
	       for (unsigned neiIdx = 0; neiIdx < par.n_nbrs; neiIdx ++) {
		    offset = nei_set_array[neiIdx];
		    nbr_patch_id =  parcelIt.GetPixel(offset) - 1;

		    // make sure pair (i,j) only count once, since they are
		    // ordered. Only upper triangular part of the matrix is
		    // filled.
		    if ( (nbr_patch_id >= 0) && (nbr_patch_id > cur_patch_id) ) {

			 // // debug neighborboundary.
			 // if (cur_patch_id == 2815 && nbr_patch_id == 2816) {
			 //      parcelIdx = parcelIt.GetIndex();
			 //      nbr_idx = parcelIt.GetIndex(offset);
			 //      printf("parcelIdx:[%i %i %i]. nbrIdx:[%i %i %i]\n", parcelIdx[0], parcelIdx[1], parcelIdx[2], nbr_idx[0], nbr_idx[1], nbr_idx[2]);
			 //      printf("neiIdx: %i, con_map: %f\n", neiIdx, con_map(cur_patch_id, nbr_patch_id));
			 // }


			 con_map(cur_patch_id, nbr_patch_id) ++;
		    }
	       } // neiIdx
	  } // in mask
     }

     return 0;
}

int build_nlinks(const vnl_matrix <double> & data, 
		 const vnl_sparse_matrix <double> & con_map,
		 vnl_sparse_matrix <double> & nlinks_map,
		 ParType & par)
{
     // compute beta. 
     double beta_sum = 0, n_edges = 0;
     unsigned row_id, col_id = 0;
     con_map.reset(); 
     while(con_map.next()) {
	  row_id = con_map.getrow();
	  col_id = con_map.getcolumn();
	  beta_sum += (data.get_row(row_id) - data.get_row(col_id)).squared_magnitude();
	  n_edges ++;
     }
     par.beta = 0.5 * (1 / (beta_sum/n_edges) );

     if (par.verbose >= 1) 
	  printf("build_nlinks(): beta = %f\n", par.beta);

     // convert the adjacency information int N-Links weights. 
     con_map.reset(); 
     double new_value = 0;
     nlinks_map.set_size(con_map.rows(), con_map.cols());
     while(con_map.next()) {
	  // get the patch sample id of a pair of neighbors.
	  row_id = con_map.getrow();
	  col_id = con_map.getcolumn();
	  new_value = par.gamma * con_map.value() * exp(- par.beta * par.beta0 * (data.get_row(row_id) - data.get_row(col_id)).squared_magnitude() );
	  nlinks_map.put(row_id, col_id, new_value); 
     };
     return 0;
}

unsigned graphcuts(vnl_vector<unsigned> & alpha,
	      const vnl_matrix <double> & data, 
	      const vnl_vector <unsigned> & hard_constraints,
	      const vnl_sparse_matrix <double> & nlinks_map,
	      const ParType & par)
{
     unsigned sample_idx = 0;
     Graph<double, double, double> G(1000, 1000);
     unsigned n_samples = data.rows();
     std::vector<unsigned> nodes(n_samples);
     for (sample_idx = 0; sample_idx < n_samples; sample_idx ++) {
	  nodes[sample_idx] = G.add_node();
     }
     
     // assign tlink weights. 
     double bg_link = 0, fg_link = 0;
     for (sample_idx = 0; sample_idx < n_samples; sample_idx ++) {
	  // if (hard_constraints[sample_idx] == HC_FG) {
	  //      bg_link = 0;
	  //      fg_link = 6 * par.gamma + 1;
	  // }
	  // else if (hard_constraints[sample_idx] == HC_BG) {
	  //      bg_link = 6 * par.gamma + 1;
	  //      fg_link = 0;
	  // }
	  // else {
	  //      // must be unknown region.
	  //      fg_link = - gmm_eval_ll(data.get_row(sample_idx), par.gmm_bg);
	  //      bg_link = - gmm_eval_ll(data.get_row(sample_idx), par.gmm_fg);
	  // }

	  fg_link = - gmm_eval_ll(data.get_row(sample_idx), par.gmm_bg);
	  bg_link = - gmm_eval_ll(data.get_row(sample_idx), par.gmm_fg);
	  G.add_tweights(nodes[sample_idx], fg_link, bg_link);
     }

     // assign nlink weights. 
     int cur_node = 0, nbr_node = 0, sample_id1 = 0, sample_id2 = 0;
     nlinks_map.reset(); 
     while(nlinks_map.next()) {
	  // get the patch sample id of a pair of neighbors.
	  sample_id1 = nlinks_map.getrow();
	  sample_id2 = nlinks_map.getcolumn();
	  cur_node = nodes[sample_id1];
	  nbr_node = nodes[sample_id2];
	  G.add_edge(cur_node, nbr_node, nlinks_map(sample_id1, sample_id2), nlinks_map(sample_id1, sample_id2));
     };

     // compute min-cut, max-flow
     G.maxflow();

     // update alpha.
     unsigned n_changes = 0;
     int sink_name = Graph<double, double, double>::SINK;
     int source_name = Graph<double, double, double>::SOURCE;
     for (sample_idx = 0; sample_idx < n_samples; sample_idx ++) {
	  unsigned old_value = alpha[sample_idx];
<<<<<<< .mine

	  if (par.baseline) {
	       // All are unknow regions in baseline mode, so they can freely
	       // move into FG or BG. (actually there is no FG in
	       // hard_constraint map (trimap) for now, so only BG can go into
	       // FG).
	       if (G.what_segment(nodes[sample_idx]) == Graph<double, double, double>::SOURCE)
		    alpha[sample_idx] = ALPHA_FG;
	       else
		    alpha[sample_idx] = ALPHA_BG;
	       
	  }
=======
	  // printf("sample: %i, node %i, graph label: %i\n", sample_idx, nodes[sample_idx], G.what_segment(nodes[sample_idx]));
	  // if (hard_constraints[sample_idx] == HC_FG) {
	  //      // make sure maxfow do not change those constraints. 
	  //      assert (G.what_segment(nodes[sample_idx]) == source_name);
	  //      alpha[sample_idx] = ALPHA_FG;
	  // }
	  // else if (hard_constraints[sample_idx] == HC_BG) {
	  //      assert(G.what_segment(nodes[sample_idx]) == sink_name);
	  //      alpha[sample_idx] = ALPHA_BG;
	  // }
	  // else {
	  //      // unknow regions.
	  //      if (G.what_segment(nodes[sample_idx]) == Graph<double, double, double>::SOURCE)
	  // 	    alpha[sample_idx] = ALPHA_FG;
	  //      else
	  // 	    alpha[sample_idx] = ALPHA_BG;
	  // }

	  if (G.what_segment(nodes[sample_idx]) == Graph<double, double, double>::SOURCE)
	       alpha[sample_idx] = ALPHA_FG;
	  else
	       alpha[sample_idx] = ALPHA_BG;
>>>>>>> .r470

	  else {
	       if (hard_constraints[sample_idx] == HC_FG) {
		    // make sure maxfow do not change those constraints. 
		    assert (G.what_segment(nodes[sample_idx]) == source_name);
		    alpha[sample_idx] = ALPHA_FG;
	       }
	       else if (hard_constraints[sample_idx] == HC_BG | hard_constraints[sample_idx] == HC_BG_NEW) {
		    assert(G.what_segment(nodes[sample_idx]) == sink_name);
		    alpha[sample_idx] = ALPHA_BG;
	       }
	       else {
		    // unknow regions.
		    if (G.what_segment(nodes[sample_idx]) == Graph<double, double, double>::SOURCE)
			 alpha[sample_idx] = ALPHA_FG;
		    else
			 alpha[sample_idx] = ALPHA_BG;
	       } // unknow regions.

	  } // else baseline. 

	  if (old_value != alpha[sample_idx])
	       n_changes ++;
     }

     return n_changes;
}

