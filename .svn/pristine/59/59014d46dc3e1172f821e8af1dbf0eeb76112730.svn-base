// once the EM is done, we need to compute the posterior distribution of the
// class labels for each patch/voxel originally in the background region. We
// call it posterior, because we assume a MRF prior on the voxel labels x. Given
// x, we can compute the marginal P(y|x), where y is the voxel intensity. The
// marginal means we integrate out the component k when copute P(y|x). This is
// different with our previous solution just on the prior MRF. The posterior
// need to be in the range of [0, 1]. We use logistic model to convert the joint
// likelihood P(x, y) to the posterior. See page 197 of Bishop's book for that.

#include <common.h>
#include <gmm.h>

using namespace std;

// include libraries and define some struts for CCP
#include <algorithm>    // std::sort
#include <vector>       // std::vector

// for mathematical morphology operations - erosion
#include "itkBinaryErodeImageFilter.h"
#include "itkBinaryDilateImageFilter.h"
#include "itkBinaryBallStructuringElement.h"
#include "itkConnectedComponentImageFilter.h"

// the struct for attributes of connected components
typedef struct ConnectedCompInfor{
     int labelValue;
     int volumeSize;
     float avgPredictProb;
     float sumPredictProb;
} myConnectedCompInfor;

// the pair data structure for returning indices in sorting
typedef std::pair<int,int> mypair;
typedef std::pair<float,int> mypairFI;

// define unsigned char type for morphological processing
typedef unsigned char PixelType3DUC;
typedef itk::Image<PixelType3DUC , 3> ImageType3DUC;
typedef itk::ImageFileWriter< ImageType3DUC >  WriterType3DUC;


int logistic(vnl_vector<double> & score_map,
	     const vnl_matrix<double> & data,
	     vnl_sparse_matrix <double> & con_map,
	     const vnl_vector<unsigned> & alpha,
	     const ParType & par);

void morphologicalProcessingTrueCandidatesVolume(ImageType3DUC::Pointer trueCandidatesVolume,
						 ImageType3DUC::Pointer trueCandidatesVolumeErosion, 
						 ImageType3DUC::Pointer trueCandidatesVolumeDilationMinusErosion);

void computeShapeScoreforCcpCandidates (ImageType3DI::Pointer ccpPredictProb,
					ImageType3DI::Pointer trimap,
					const int& numTopCcptoEvaluate,
					std::vector< std::pair<int, int> >& ccpVectorPairs,
					ConnectedCompInfor allConnectedComponents[],
					const float& thresholdScoreforTopCandidates,
					std::string& output_image_file);

int activeLearnCCP(ImageType3DF::Pointer predictProb,
		   ImageType3DI::Pointer alphaLabel,
		   ImageType3DI::Pointer trimap,
		   const float& thresholdPredictProb,
		   const float& thresholdScoreforTopCandidates,
		   std::string& output_image_file);


// Read new object's labels, either by self training, or by act-learning, and
// update the constraints.
int update_hardconstraints(const vnl_vector<double> & score_map, 
			   ImageType3DI::Pointer parcelPtr, 
			   const vnl_vector<unsigned> & alpha,
			   ImageType3DC::Pointer init_constraintPtr,
			   vnl_vector<unsigned> & hard_constraints,
			   const ParType & par);
