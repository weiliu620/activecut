#include <common.h>
#include <gmm.h>
#include <graphcuts.h>
#include <utility.h>

namespace po = boost::program_options;

int load_data(ImageType4DF::Pointer dataPtr,
	      ImageType3DI::Pointer parcelPtr,
	      vnl_matrix<double> & D);

int load_constraints(ImageType3DI::Pointer parcelPtr,
		     std::string init_image_file,
		     vnl_vector<unsigned> & hard_constraints,
		     const ParType & par);

int load_priors(ImageType3DI::Pointer parcelPtr,
		std::string prior_file,
		vnl_matrix<double> & priors,
		const ParType & par);

int main(int argc, char* argv[])
{
     // std::string t1_file, t2_file, flair_file, gre_file, swi_file;
     std::string input_image_file, init_image_file, alpha_file, tlink_image_file, nlink_image_file, parcel_map_file, gmm_fg_file, gmm_bg_file, prior_file, ll_fg_file, ll_bg_file;
     
     // all parameters including GMM.
     ParType par;
     unsigned maxem = 0;;
     unsigned cov_type = 0;
     bool cov_shared = false;

     // program options.
     po::options_description mydesc("Options can only used at commandline");
     mydesc.add_options()
	  ("help,h", "Grab cut segmentation of 3D multi-channel traumatic brain injury (TBI) images.")

	  ("ncompbg,b", po::value<unsigned>(&par.gmm_bg.n_comp)->default_value(3),
	   "number of Gaussian components in background.")

	  ("ncompfg,f", po::value<unsigned>(&par.gmm_fg.n_comp)->default_value(2),
	   "number of Gaussian components in foreground.")

	  ("maxem,m", po::value<unsigned>(&maxem)->default_value(50),
	   "Max number of EM iterations.")

	  ("kmeansruns,r", po::value<unsigned>(&par.kmeansruns)->default_value(5),
	   "number of kmeans runs.")

	  ("betaf", po::value<double>(&par.gmm_fg.beta)->default_value(1),
	   "smoothness constraint for foreground gmm segmentation.")

	  ("betab", po::value<double>(&par.gmm_bg.beta)->default_value(1),
	   "Smoothness constraint for background gmm segmentation.")

	  ("gamma,g", po::value<double>(&par.gamma)->default_value(5),
	   "alpha smoothness constraint.")

	  ("beta0", po::value<double>(&par.beta0)->default_value(1),
	   "An additional parameter in front of beta. ")

	  ("neighbors,n", po::value<unsigned>(&par.n_nbrs)->default_value(6),
	   "number of neighbors of a voxel for graphcuts N-Links. Valid values are 6, 18 and 26. ")

	  ("covtype", po::value<unsigned>(&cov_type)->default_value(1),
	   "Type of covariance matrix. 0 for full matrix, 1 for diagonal, 3 for identity.")

	  ("covshared", po::bool_switch(&cov_shared), 
	   "Whether all components of GMM has same covariance matrix. Default is no.")

	  ("data,d", po::value<std::string>(&input_image_file),
	   "Input all-channel image file. A 4D gipl or nii or nii.gz file.")

	  ("init,i", po::value<std::string>(&init_image_file),
	   "A 3D volume image giving the user's initial input. Inside the box will be init'd unkown, and outside will be init'd as background.")

	  ("prior", po::value<std::string>(&prior_file),
	   "4D file for the GM/WM/CSF prior probability. Will be used for FG init.")

	  ("parcel,p", po::value<std::string>(&parcel_map_file),
	   "A 3D volume image giving the parcellation of the brain. Values in the image is [1, N], meaning N super-pixels. This is also use as a mask image. Outside of the brain is zero.")
	  ("alphafile,a", po::value<std::string>(&alpha_file),
	   "The output segmentation file. Will be binary volume with same size as input data.")

	  ("gmmfg", po::value<std::string>(&gmm_fg_file)->default_value("gmmfg.nii.gz"),
	   "Foreground GMM segmentation label image.")

	  ("gmmbg", po::value<std::string>(&gmm_bg_file)->default_value("gmmbg.nii.gz"),
	   "Background GMM segmentation label image.")

	  ("llfg", po::value<std::string>(&ll_fg_file)->default_value("llfg.nii.gz"),
	   "Foreground log-likelihood image file.")

	  ("llbg", po::value<std::string>(&ll_bg_file)->default_value("llbg.nii.gz"),
	   "Background log-likelihodo image file.")

	  ("tlink", po::value<std::string>(&tlink_image_file)->default_value("tlink.nii.gz"),
	   "T-Link image for debugging.")

	  ("nlink", po::value<std::string>(&nlink_image_file)->default_value("nlink.nii.gz"),
	   "N-Link image for debugging.")

	  ("seed,s", po::value<unsigned>(&par.seed)->default_value(0),
	   "Seed for random number generator.")

	  ("verbose,v", po::value<unsigned>(&par.verbose)->default_value(0),
	   "verbose level in [0, 3]. ")
	  ;

     po::variables_map vm;        
     po::store(po::parse_command_line(argc, argv, mydesc), vm);
     po::notify(vm);    

     try {
	  if ( (vm.count("help")) | (argc == 1) ) {
	       std::cout << "Usage: grabcut [options]\n";
	       std::cout << mydesc << "\n";
	       return 0;
	  }
     }
     catch(std::exception& e) {
	  std::cout << e.what() << "\n";
	  return 1;
     }    

     // read data images.
     ReaderType4DF::Pointer dataReader = ReaderType4DF::New();
     dataReader->SetFileName(input_image_file);
     dataReader->Update();
     ImageType4DF::Pointer dataPtr = dataReader->GetOutput();

     // read super-pixel images.
     ReaderType3DI::Pointer parcelReader = ReaderType3DI::New();
     parcelReader->SetFileName(parcel_map_file);
     parcelReader->Update();
     ImageType3DI::Pointer parcelPtr = parcelReader->GetOutput();

     // convert the image into a NxP matrix, where N is the number of
     // super-pixel, and P is the number of channels.

     vnl_matrix <double> data;

     // save the user input constraints, which include FG/BG/UNKNOWN.
     vnl_vector <unsigned> hard_constraints;

     load_data(dataPtr, parcelPtr, data);

     // fill there values since load_* func use them.
     par.n_channels = data.cols();
     par.n_samples = data.rows();

     load_constraints(parcelPtr, init_image_file, hard_constraints, par);

     // load prior probability (mostly for FG).
     vnl_matrix <double> priors;
     load_priors(parcelPtr, prior_file, priors, par);
     save_priors(par, priors, parcelPtr, "saved_priors.nii.gz");

     // for debugging.
     // save_patches(parcelPtr, data, "patches.nii.gz", par);

     // init the remaining part of par.

     par.gmm_fg.comp.resize(par.gmm_fg.n_comp);
     par.gmm_fg.pi.set_size(par.gmm_fg.n_comp);
     par.gmm_fg.name = "GMM_FG";
     par.gmm_bg.comp.resize(par.gmm_bg.n_comp);
     par.gmm_bg.pi.set_size(par.gmm_bg.n_comp);
     par.gmm_bg.name = "GMM_BG";

     for (unsigned comp_id = 0; comp_id < par.gmm_fg.n_comp; comp_id ++) {
	  par.gmm_fg.comp[comp_id].label = 0;
	  par.gmm_fg.comp[comp_id].numPts = 0;
	  par.gmm_fg.comp[comp_id].mu.set_size(par.n_channels);
	  par.gmm_fg.comp[comp_id].mu.fill(0);
	  par.gmm_fg.comp[comp_id].cov.set_size(par.n_channels, par.n_channels);
	  par.gmm_fg.comp[comp_id].cov.fill(0);
	  par.gmm_fg.comp[comp_id].inv_cov.set_size(par.n_channels, par.n_channels);
	  par.gmm_fg.comp[comp_id].inv_cov.fill(0);
     }
     for (unsigned comp_id = 0; comp_id < par.gmm_bg.n_comp; comp_id ++) {
	  par.gmm_bg.comp[comp_id].label = 0;
	  par.gmm_bg.comp[comp_id].numPts = 0;
	  par.gmm_bg.comp[comp_id].mu.set_size(par.n_channels);
	  par.gmm_bg.comp[comp_id].mu.fill(0);
	  par.gmm_bg.comp[comp_id].cov.set_size(par.n_channels, par.n_channels);
	  par.gmm_bg.comp[comp_id].cov.fill(0);
	  par.gmm_bg.comp[comp_id].inv_cov.set_size(par.n_channels, par.n_channels);
	  par.gmm_bg.comp[comp_id].inv_cov.fill(0);
     }

     vnl_vector <unsigned> alpha(par.n_samples, 0);
     // initialize alpha vector from user input. 
     for (unsigned sample_id = 0; sample_id < par.n_samples; sample_id ++) {
	  if (hard_constraints[sample_id] == HC_FG) alpha[sample_id] = ALPHA_FG;

	  else if (hard_constraints[sample_id] == HC_BG) alpha[sample_id] = ALPHA_BG;
	  else alpha[sample_id] = ALPHA_FG; // for unkown regions, init to FG. 
     }


     // pre-compute the N-Links. 
     vnl_sparse_matrix<double> con_map;
     vnl_sparse_matrix<double> nlinks;
     build_adjmat(parcelPtr, data, con_map, par);
     build_nlinks(data, con_map, nlinks, par);

     vnl_matrix<double> gmm_labels(par.n_samples, par.gmm_fg.n_comp > par.gmm_bg.n_comp? par.gmm_fg.n_comp: par.gmm_bg.n_comp, 0);

     // Kmeans segmentation on FG and BG.
     kmeans(data, alpha, gmm_labels, par, ALPHA_BG);
     kmeans(data, alpha, gmm_labels, par, ALPHA_FG);

     save_gmm_labelmap(gmm_labels, par, alpha, ALPHA_FG, parcelPtr, gmm_fg_file);
     save_gmm_labelmap(gmm_labels, par, alpha, ALPHA_BG, parcelPtr, gmm_bg_file);

     // do a M0 step, to estimate gmm parameters from kmeans labeling.
     gmm_mstep(data, gmm_labels, alpha, ALPHA_FG, par.gmm_fg, cov_shared, cov_type);
     gmm_mstep(data, gmm_labels, alpha, ALPHA_BG, par.gmm_bg, cov_shared, cov_type);
     print_par(par);

     if (par.verbose >= 1) {
	  printf("gragcutseg(): FG After M0. LL = %E, ELL = %E, LB = %E, KL = %E\n", 
		 eval_ll(data, alpha, par.gmm_fg, ALPHA_FG), 
		 eval_ell(data, gmm_labels, alpha, par.gmm_fg, ALPHA_FG), 
		 low_bound(data, gmm_labels, alpha, par.gmm_fg, ALPHA_FG),
		 kl_dvg(data, con_map, gmm_labels, alpha, par.gmm_fg, ALPHA_FG));
	  printf("gragcutseg(): BG After M0. LL = %E, ELL = %E, LB = %E, KL = %E\n", 
		 eval_ll(data, alpha, par.gmm_bg, ALPHA_BG), 
		 eval_ell(data, gmm_labels, alpha, par.gmm_bg, ALPHA_BG), 
		 low_bound(data, gmm_labels, alpha, par.gmm_bg, ALPHA_BG),
		 kl_dvg(data, con_map, gmm_labels, alpha, par.gmm_bg, ALPHA_BG));
     }

     unsigned alpha_change = 1e6;
     double LL_bg_old = 0, LL_bg = -1e10, LL_fg_old = 0, LL_fg = -1e10;
     bool LL_changed = true;
     unsigned em_iter = 0;

     // while( (LL_changed || alpha_change > EPS) && em_iter < maxem)
     while( (LL_changed ) && em_iter < maxem)
     {
	  em_iter ++;
     	  gmm_estep(data, con_map, gmm_labels, alpha, ALPHA_FG, par.gmm_fg);
     	  gmm_estep(data, con_map, gmm_labels, alpha, ALPHA_BG, par.gmm_bg);

	  // after E step, lower bound as func of q(z) will increase, and lower
	  // bound will be equal to marginal P(x). KL should be zero, 
	  if (par.verbose >= 1) {
	       printf("gragcutseg(): FG After E%i. LL = %E, ELL = %E, LB = %E, KL = %E\n", 
		      em_iter,
		      eval_ll(data, alpha, par.gmm_fg, ALPHA_FG), 
		      eval_ell(data, gmm_labels, alpha, par.gmm_fg, ALPHA_FG), 
		      low_bound(data, gmm_labels, alpha, par.gmm_fg, ALPHA_FG),
		      kl_dvg(data, con_map, gmm_labels, alpha, par.gmm_fg, ALPHA_FG));
	       printf("gragcutseg(): BG After E%i. LL = %E, ELL = %E, LB = %E, KL = %E\n", 
		      em_iter,
		      eval_ll(data, alpha, par.gmm_bg, ALPHA_BG), 
		      eval_ell(data, gmm_labels, alpha, par.gmm_bg, ALPHA_BG), 
		      low_bound(data, gmm_labels, alpha, par.gmm_bg, ALPHA_BG),
		      kl_dvg(data, con_map, gmm_labels, alpha, par.gmm_bg, ALPHA_BG));
	       printf("\n");
	  }

	  // M step. Estimate parameters. 
	  gmm_mstep(data, gmm_labels, alpha, ALPHA_FG, par.gmm_fg, cov_shared, cov_type);
	  gmm_mstep(data, gmm_labels, alpha, ALPHA_BG, par.gmm_bg, cov_shared, cov_type);

	  // now after theta_old --> theta_new, lower bound will increase. 
	  if (par.verbose >= 1) {
	       printf("gragcutseg(): FG After M%i. LL = %E, ELL = %E, LB = %E, KL = %E\n", 
		      em_iter,
		      eval_ll(data, alpha, par.gmm_fg, ALPHA_FG), 
		      eval_ell(data, gmm_labels, alpha, par.gmm_fg, ALPHA_FG), 
		      low_bound(data, gmm_labels, alpha, par.gmm_fg, ALPHA_FG),
		      kl_dvg(data, con_map, gmm_labels, alpha, par.gmm_fg, ALPHA_FG));
	       printf("gragcutseg(): BG After M%i. LL = %E, ELL = %E, LB = %E, KL = %E\n", 
		      em_iter,
		      eval_ll(data, alpha, par.gmm_bg, ALPHA_BG), 
		      eval_ell(data, gmm_labels, alpha, par.gmm_bg, ALPHA_BG), 
		      low_bound(data, gmm_labels, alpha, par.gmm_bg, ALPHA_BG),
		      kl_dvg(data, con_map, gmm_labels, alpha, par.gmm_bg, ALPHA_BG));
	       printf("\n\n");
	  }

	  LL_fg_old = LL_fg;
	  LL_bg_old = LL_bg;
	  LL_fg = eval_ll(data, alpha, par.gmm_fg, ALPHA_FG);
	  LL_bg = eval_ll(data, alpha, par.gmm_bg, ALPHA_BG);

	  LL_changed = ( fabs((LL_fg - LL_fg_old)/LL_fg_old) > EPS) || ( fabs((LL_bg - LL_bg_old)/LL_bg_old) > EPS) ; 

	  // graphcuts segmentation. Update alpha.
	  alpha_change = graphcuts(alpha, data, hard_constraints, nlinks, par);
	  printf("alpha change: %i\n", alpha_change);
     }

     save_gmm_posterior(gmm_labels, par, alpha, ALPHA_FG, parcelPtr, gmm_fg_file);
     save_gmm_posterior(gmm_labels, par, alpha, ALPHA_BG, parcelPtr, gmm_bg_file);

     vnl_vector<double> llmap_fg(par.n_samples, 0);
     for (unsigned n = 0; n < par.n_samples; n ++) {
	  llmap_fg[n] = gmm_eval_ll(data.get_row(n), par.gmm_fg) - gmm_eval_ll(data.get_row(n), par.gmm_bg);
     }
     save_alpha(par, alpha, parcelPtr, alpha_file);
     save_llmap(par, llmap_fg, parcelPtr, ll_fg_file);
     
     return 0;
}

int load_data(ImageType4DF::Pointer dataPtr,
	      ImageType3DI::Pointer parcelPtr,
	      vnl_matrix<double> & D)
{
     unsigned spixel_id = 0;
     ImageType4DF::SizeType dataSize = dataPtr->GetLargestPossibleRegion().GetSize();
     IteratorType4DF dataIt(dataPtr, dataPtr->GetLargestPossibleRegion());
     ImageType4DF::IndexType dataIdx;

     ImageType3DI::SizeType parcelSize = parcelPtr->GetLargestPossibleRegion().GetSize();
     IteratorType3DI parcelIt(parcelPtr, parcelPtr->GetLargestPossibleRegion());
     ImageType3DI::IndexType parcelIdx;

     // find how many super-pixels. i.e. the max of the image.
     typedef itk::MinimumMaximumImageCalculator <ImageType3DI> ImageCalculatorFilterType;
     ImageCalculatorFilterType::Pointer imageCalculatorFilter = ImageCalculatorFilterType::New ();

     imageCalculatorFilter->SetImage(parcelPtr);
     imageCalculatorFilter->ComputeMaximum();
     unsigned n_samples = imageCalculatorFilter->GetMaximum();
     unsigned n_channels = dataSize[3];
     
     D.set_size(n_samples, n_channels);
     D.fill( 0 );
     
     vnl_vector<unsigned> num_pixels(n_samples, 0); // num of pixels in each component.

     for (parcelIt.GoToBegin(); !parcelIt.IsAtEnd(); ++ parcelIt) {
	  if (parcelIt.Get() > 0) {
	       parcelIdx = parcelIt.GetIndex();
	       spixel_id = parcelIt.Get() - 1; // convert to zero-based indexing.
	       dataIdx[0] = parcelIdx[0];
	       dataIdx[1] = parcelIdx[1];
	       dataIdx[2] = parcelIdx[2];
	       for (unsigned channel_id = 0; channel_id < n_channels; channel_id ++) {
		    dataIdx[3] = channel_id;
		    D[spixel_id][channel_id] += dataPtr->GetPixel(dataIdx);
		    num_pixels[spixel_id] += 1;
	       }
	  } // in mask
     }

     // averaging pixel intensities in a super-pixel.
     for (spixel_id = 0; spixel_id < n_samples; spixel_id ++) {
	  for (unsigned channel_id = 0; channel_id < n_channels; channel_id ++) {
	       D[spixel_id][channel_id] /= num_pixels[spixel_id];
	  }
     }


}

int load_constraints(ImageType3DI::Pointer parcelPtr,
		     std::string init_image_file,
		     vnl_vector<unsigned> & hard_constraints,
		     const ParType & par)
{
     unsigned spixel_id = 0;
     ImageType3DI::SizeType parcelSize = parcelPtr->GetLargestPossibleRegion().GetSize();
     IteratorType3DI parcelIt(parcelPtr, parcelPtr->GetLargestPossibleRegion());
     ImageType3DI::IndexType parcelIdx;

     // find how many super-pixels. i.e. the max of the image.
     typedef itk::MinimumMaximumImageCalculator <ImageType3DI> ImageCalculatorFilterType;
     ImageCalculatorFilterType::Pointer imageCalculatorFilter = ImageCalculatorFilterType::New ();

     imageCalculatorFilter->SetImage(parcelPtr);
     imageCalculatorFilter->ComputeMaximum();
     unsigned n_samples = imageCalculatorFilter->GetMaximum();
     hard_constraints.set_size(n_samples);

     // read user initialized image.
     ReaderType3DC::Pointer initReader = ReaderType3DC::New();
     initReader->SetFileName(init_image_file);
     initReader->Update();
     ImageType3DC::Pointer initPtr = initReader->GetOutput();
     IteratorType3DC initIt(initPtr, initPtr->GetLargestPossibleRegion());
     ImageType3DC::IndexType initIdx;

     // convert voxel-based prior to ROI/patch based. we just average the
     // probability over all voxels in a patch.
     vnl_matrix<unsigned> accu(n_samples, 3, 0);
     for (parcelIt.GoToBegin(), initIt.GoToBegin(); !initIt.IsAtEnd(); ++ parcelIt, ++ initIt) {
	  if (parcelIt.Get() > 0) { // in mask
	       spixel_id = parcelIt.Get() - 1;
	       if (initIt.Get() == HC_FG) { // fg
		    accu[spixel_id][0] ++;
	       }
	       else if (initIt.Get() == HC_BG) { // bg
		    accu[spixel_id][1] ++;
	       }
	       else { // unknown region will be init'd as foreground!
		    accu[spixel_id][2] ++;
	       }
	  } // in mask
	  
     }

     // decide which fg/bg/unknown that a ROI takes. In the future, may need
     // consider the case that half voxels are fg, half are bg. Then this
     // ROI/patch may be defined as unknown, as there is ambiguity from human
     // init.
     vnl_vector<unsigned> this_accu(3);
     unsigned max_pos = 0;
     for (spixel_id = 0; spixel_id < n_samples; spixel_id ++) {
	  this_accu = accu.get_row(spixel_id);
	  // if most pixels in a region take some value, the roi take it, too.
	  max_pos = this_accu.arg_max();
	  if (max_pos == 0) { // fg
	       hard_constraints[spixel_id] = HC_FG;
	  }
	  else if (max_pos == 1) { // bg
	       hard_constraints[spixel_id] = HC_BG;
	  } 
	  else {
	       hard_constraints[spixel_id] = HC_UNKNOWN;
	  }
     }

     return 0;
}

int load_priors(ImageType3DI::Pointer parcelPtr,
		std::string prior_file,
		vnl_matrix<double> & priors,
		const ParType & par)
{
     unsigned spixel_id = 0;
     ImageType3DI::SizeType parcelSize = parcelPtr->GetLargestPossibleRegion().GetSize();
     IteratorType3DI parcelIt(parcelPtr, parcelPtr->GetLargestPossibleRegion());
     ImageType3DI::IndexType parcelIdx;

     // find how many super-pixels. i.e. the max of the image.
     typedef itk::MinimumMaximumImageCalculator <ImageType3DI> ImageCalculatorFilterType;
     ImageCalculatorFilterType::Pointer imageCalculatorFilter = ImageCalculatorFilterType::New ();
     imageCalculatorFilter->SetImage(parcelPtr);
     imageCalculatorFilter->ComputeMaximum();

     unsigned n_samples = imageCalculatorFilter->GetMaximum();

     double n_comp = (par.gmm_fg.n_comp > par.gmm_fg.n_comp?par.gmm_bg.n_comp:par.gmm_bg.n_comp);
     priors.set_size(n_samples, n_comp);
     vnl_vector<unsigned> num_pixels(n_samples, 0); // num of pixels in each component.

     // read 4D prior image. (last dim is num of Gaussian components)
     ReaderType4DF::Pointer priorReader = ReaderType4DF::New();
     priorReader->SetFileName(prior_file);
     priorReader->Update();
     ImageType4DF::Pointer priorPtr = priorReader->GetOutput();
     IteratorType4DF priorIt(priorPtr, priorPtr->GetLargestPossibleRegion());
     ImageType4DF::IndexType priorIdx;

     for (parcelIt.GoToBegin(); !parcelIt.IsAtEnd(); ++ parcelIt) {
	  if (parcelIt.Get() > 0) { // in mask
	       spixel_id = parcelIt.Get() - 1;
	       parcelIdx = parcelIt.GetIndex();
	       priorIdx[0] = parcelIdx[0];
	       priorIdx[1] = parcelIdx[1];
	       priorIdx[2] = parcelIdx[2];
	       for (priorIdx[3] = 0; priorIdx[3] < n_comp; priorIdx[3] ++) {
		    priors(spixel_id, priorIdx[3]) += priorPtr->GetPixel(priorIdx);
	       }
	       num_pixels[spixel_id] += 1;
	  } // in mask.
     }

     // normalize the atlas
     for (unsigned n = 0; n < par.n_samples; n ++) {
	  priors.scale_row(n, 1/priors.get_row(n).sum() );
     }
     return 0;
}
