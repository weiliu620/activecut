#include <common.h>
#include <utility.h>
#include "itkAddImageFilter.h"
#include "itkImageDuplicator.h"
struct FeatureType {
     std::vector<double> data;
     itk::Point<double, 3> coord;
};

struct SLICParType {
     unsigned patch_size;
     double compact;
     double var;
     double upper_th;
     double lower_th;
     unsigned verbose;
};

bool find_cc(ImageType3DI::IndexType lb,
	    ImageType3DI::IndexType hb,
	    ImageType4DF::Pointer dataPtr,
	    ImageType3DI::Pointer maskPtr,
	     ImageType4DF::IndexType & ccIdx);

int kmeans_updatelabels(ImageType4DF::Pointer dataPtr,
			ImageType3DI::Pointer maskPtr,
			ImageType3DU::Pointer labelPtr,
			const std::vector<FeatureType> & cc,
			const SLICParType & par);

int kmeans_updatecc(ImageType4DF::Pointer dataPtr,
		    ImageType3DI::Pointer maskPtr,
		    ImageType3DU::Pointer labelPtr,
		    std::vector<FeatureType> & cc);

int compute_dist(FeatureType p1, FeatureType p2, double patch_size, double compact);

int save_label_map(ImageType3DU::Pointer labelPtr,	    
		   ImageType3DI::Pointer maskPtr,
		   std::string filename);

int build_edge(ImageType4DF::Pointer dataPtr,
	       ImageType3DI::Pointer maskPtr,
	       ImageType3DF::Pointer edgePtr,
	       std::vector<FeatureType> & cc);

namespace po = boost::program_options;
int main(int argc, char* argv[])
{
     SLICParType par;
     unsigned n_patches = 0, kmeans_run = 0;
     std::string mask_file, input_image_file, label_file;
     // program options.
     po::options_description mydesc("Options can only used at commandline");
     mydesc.add_options()
	  ("help,h", "SLIC superpixel segmentation.")

	  // ("npatches,n", po::value<unsigned>(&n_patches)->default_value(5000),
	  //  "Num of patches.")

	  ("patchesize,s", po::value<unsigned>(&par.patch_size)->default_value(5),
	   "Length of the edge of the patch cube. ")

	  ("compact,c", po::value<double>(&par.compact)->default_value(5),
	   "Compact parameter. Large compact gives more compact regions.")

	  ("var", po::value<double>(&par.var)->default_value(1),
	   "variance of canny edge filter.")

	  ("upth,u", po::value<double>(&par.upper_th)->default_value(1),
	   "Upper threshold of canny edge filter.")

	  ("lowth,l", po::value<double>(&par.lower_th)->default_value(0),
	   "Lower threshold of canny edge filter.")

	  ("kmeansrun,r", po::value<unsigned>(&kmeans_run)->default_value(10),
	   "Num of K-Means iterations.")

	  ("data,d", po::value<std::string>(&input_image_file),
	   "Input all-channel image file. A 4D gipl or nii or nii.gz file.")

	  ("mask,m", po::value<std::string>(&mask_file),
	   "mask file.")

	  ("label,l", po::value<std::string>(&label_file),
	   "Output lael file. intensity in [1, N].")

	  ("verbose,v", po::value<unsigned>(&par.verbose)->default_value(0),
	   "verbose level in [0, 3]. ")
	  ;

     po::variables_map vm;        
     po::store(po::parse_command_line(argc, argv, mydesc), vm);
     po::notify(vm);    

     try {
	  if ( (vm.count("help")) | (argc == 1) ) {
	       std::cout << "Usage: grabcut [options]\n";
	       std::cout << mydesc << "\n";
	       return 0;
	  }
     }
     catch(std::exception& e) {
	  std::cout << e.what() << "\n";
	  return 1;
     }    

     // read data images.
     ReaderType4DF::Pointer dataReader = ReaderType4DF::New();
     dataReader->SetFileName(input_image_file);
     dataReader->Update();
     ImageType4DF::Pointer dataPtr = dataReader->GetOutput();
     ImageType4DF::SizeType dataSize = dataPtr->GetLargestPossibleRegion().GetSize();

     // read mask images.
     ReaderType3DI::Pointer maskReader = ReaderType3DI::New();
     maskReader->SetFileName(mask_file);
     maskReader->Update();
     ImageType3DI::Pointer maskPtr = maskReader->GetOutput();

     ImageType3DI::SizeType maskSize = maskPtr->GetLargestPossibleRegion().GetSize();
     IteratorType3DI maskIt(maskPtr, maskPtr->GetLargestPossibleRegion());
     ImageType3DI::IndexType maskIdx;
     ImageType3DI::IndexType idx_lb, idx_hb;

     // compute total num of points
     unsigned n_pts = 0;
     for (maskIt.GoToBegin(); !maskIt.IsAtEnd(); ++maskIt) {
	  if (maskIt.Get() > 0) {
	       n_pts ++;
	  }
     }

     // look for initial cluster centers.
     std::vector<FeatureType> cc;
     ImageType4DF::IndexType this_idx, zero_idx;
     this_idx.Fill(0);
     zero_idx.Fill(0);
     FeatureType this_point;
     this_point.coord.Fill(0);
     this_point.data.resize(dataSize[3]);
     unsigned ih = 0, jh = 0, kh = 0;
     for (unsigned i = 0; i < maskSize[0]; i = i + par.patch_size) {
	  ih = i + par.patch_size - 1;
	  if (ih >= maskSize[0]) ih = maskSize[0] - 1;
	  for (unsigned j = 0; j < maskSize[1]; j = j + par.patch_size) {
	       jh = j + par.patch_size - 1;
	       if (jh >= maskSize[1]) jh = maskSize[1] - 1;
	       for (unsigned k = 0; k < maskSize[2]; k = k + par.patch_size) {
		    kh = k + par.patch_size - 1;
		    if (kh >= maskSize[2]) kh = maskSize[2] - 1;
		    // record two corner of the cube.
		    idx_lb[0] = i, idx_hb[0] = ih;
		    idx_lb[1] = j, idx_hb[1] = jh;
		    idx_lb[2] = k, idx_hb[2] = kh;

		    if (find_cc(idx_lb, idx_hb, dataPtr, maskPtr, this_idx)) {
			 this_point.coord[0] = this_idx[0];
			 this_point.coord[1] = this_idx[1];
			 this_point.coord[2] = this_idx[2];
			 for (this_idx[3] = 0; this_idx[3] < dataSize[3]; this_idx[3] ++) {
			      this_point.data[this_idx[3]] = dataPtr->GetPixel(this_idx);
			 }
			 cc.push_back(this_point);
			 // std::cout << this_idx << std::endl;
			 // std::cout << "lb:" << idx_lb << "   hb:" << idx_hb << "   coord: " << this_point.coord << "   data:" << this_point.data[0] << "\n";
		    }
	       } // k
	  } // j
     } // i

     // create a edge image. 
     ImageType3DF::RegionType edgeRegion = maskPtr->GetLargestPossibleRegion();
     ImageType3DF::Pointer edgePtr = ImageType3DF::New();
     edgePtr->SetRegions(edgeRegion);
     edgePtr->Allocate();
     edgePtr->FillBuffer(0);

     // create a label image. 
     ImageType3DU::RegionType labelRegion = maskPtr->GetLargestPossibleRegion();
     ImageType3DU::Pointer labelPtr = ImageType3DU::New();
     labelPtr->SetRegions(labelRegion);
     labelPtr->Allocate();
     labelPtr->FillBuffer(0);

     unsigned kmeans_iter = 0;
     unsigned n_changed = 1e7;
     while(double(n_changed)/double(n_pts) > 0.001 && kmeans_iter < kmeans_run) {
	  n_changed = kmeans_updatelabels(dataPtr, maskPtr, labelPtr, cc, par);
	  kmeans_updatecc(dataPtr, maskPtr, labelPtr, cc);
	  printf("kmeans iter %i done. changed voxels: %i \n", kmeans_iter, n_changed);
	  kmeans_iter ++;
     }
     save_label_map(labelPtr, maskPtr, label_file);
}
     
// given a cube lower and higher bound/cornder, tell if this is (even partly) in
// mask. If yes, save the cluster center and return 1. Otherwise return 0. 
bool find_cc(ImageType3DI::IndexType lb,
	    ImageType3DI::IndexType hb,
	    ImageType4DF::Pointer dataPtr,
	    ImageType3DI::Pointer maskPtr,
	    ImageType4DF::IndexType & ccIdx)
{
     ImageType3DI::IndexType maskIdx;
     ccIdx.Fill(0);
     maskIdx.Fill(0);
     unsigned n_pts = 0; // points in mask.
     itk::Point<double, 3> cc;
     cc.Fill(0);

     for (maskIdx[0] = lb[0]; maskIdx[0] <= hb[0]; maskIdx[0] ++) {
	  for (maskIdx[1] = lb[1]; maskIdx[1] <= hb[1]; maskIdx[1] ++) {
	       for (maskIdx[2] = lb[2]; maskIdx[2] <= hb[2]; maskIdx[2] ++) {
		    if (maskPtr->GetPixel(maskIdx) > 0 ) {
			 n_pts ++;
			 cc[0] += maskIdx[0];
			 cc[1] += maskIdx[1];
			 cc[2] += maskIdx[2];
		    }
	       }
	  }
     }
     // convert to index. may be rounding error.
     ccIdx[0] = cc[0] / n_pts;
     ccIdx[1] = cc[1] / n_pts;
     ccIdx[2] = cc[2] / n_pts;
     if (n_pts > 0)   return true;
     else return false;
}

int kmeans_updatelabels(ImageType4DF::Pointer dataPtr,
			ImageType3DI::Pointer maskPtr,
			ImageType3DU::Pointer labelPtr,
			const std::vector<FeatureType> & cc,
			const SLICParType & par)

{
     // create a dist image to save the current min distance of each voxel to
     // it's cluster center.
     ImageType3DF::RegionType distRegion = maskPtr->GetLargestPossibleRegion();
     ImageType3DF::Pointer distPtr = ImageType3DF::New();
     distPtr->SetRegions(distRegion);
     distPtr->Allocate();
     distPtr->FillBuffer(1e6); // init to big value.

     ImageType4DF::IndexType dataIdx;
     ImageType4DF::SizeType dataSize = dataPtr->GetLargestPossibleRegion().GetSize();

     ImageType3DI::IndexType maskIdx;
     ImageType3DI::SizeType maskSize = maskPtr->GetLargestPossibleRegion().GetSize();
     FeatureType this_point;
     this_point.coord.Fill(0);
     this_point.data.resize(dataSize[3]);

     // duplicate a label image for comparison later. 
     typedef itk::ImageDuplicator< ImageType3DU > DuplicatorType;
     DuplicatorType::Pointer duplicator = DuplicatorType::New();
     duplicator->SetInputImage(labelPtr);
     duplicator->Update();
     ImageType3DU::Pointer clonelabelPtr = duplicator->GetOutput();

     for (unsigned k = 0; k < cc.size(); k++) {
	  
	  unsigned lb0 = int(cc[k].coord[0] - par.patch_size) >= 0? int(cc[k].coord[0] - par.patch_size):0;
	  unsigned ub0 = int(cc[k].coord[0] + par.patch_size) <= maskSize[0] - 1 ? int(cc[k].coord[0] + par.patch_size): maskSize[0]-1;
	  for (maskIdx[0] = lb0; maskIdx[0] <= ub0; maskIdx[0] ++) {

	       unsigned lb1 = int(cc[k].coord[1] - par.patch_size) >= 0? int(cc[k].coord[1] - par.patch_size):0;
	       unsigned ub1 = int(cc[k].coord[1] + par.patch_size) <= maskSize[1] - 1 ? int(cc[k].coord[1] + par.patch_size): maskSize[1]-1;
	       for (maskIdx[1] = lb1; maskIdx[1] <= ub1; maskIdx[1] ++) {

		    unsigned lb2 = int(cc[k].coord[2] - par.patch_size) >= 0? int(cc[k].coord[2] - par.patch_size):0;
		    unsigned ub2 = int(cc[k].coord[2] + par.patch_size) <= maskSize[2] - 1 ? int(cc[k].coord[2] + par.patch_size): maskSize[2]-1;
		    for (maskIdx[2] = lb2; maskIdx[2] <= ub2; maskIdx[2] ++) {

			 if (maskPtr->GetPixel(maskIdx) > 0 ) {
			      // construct a feature vector.
			      this_point.coord[0] = maskIdx[0];
			      this_point.coord[1] = maskIdx[1];
			      this_point.coord[2] = maskIdx[2];
			      dataIdx[0] = maskIdx[0];
			      dataIdx[1] = maskIdx[1];
			      dataIdx[2] = maskIdx[2];
			      for (dataIdx[3] = 0; dataIdx[3] < dataSize[3]; dataIdx[3] ++) {
				   this_point.data[dataIdx[3]] = dataPtr->GetPixel(dataIdx);
			      }
			      double this_dist = compute_dist(this_point, cc[k], par.patch_size, par.compact);
			      if (this_dist < distPtr->GetPixel(maskIdx)) {
				   labelPtr->SetPixel(maskIdx, k);
				   distPtr->SetPixel(maskIdx, this_dist);
			      }
			 } // mask
		    } // [2]
	       } // [1]
	  } // [0]
     } // k

     // compute num of change labels.
     unsigned n_changed = 0;
     IteratorType3DU labelIt(labelPtr, labelPtr->GetLargestPossibleRegion());
     IteratorType3DU clonelabelIt(clonelabelPtr, clonelabelPtr->GetLargestPossibleRegion());
     for (clonelabelIt.GoToBegin(), labelIt.GoToBegin(); !labelIt.IsAtEnd();++labelIt, ++clonelabelIt) {
	  if (labelIt.Get() != clonelabelIt.Get() ) n_changed ++;
     }
     
     return n_changed;
}

int kmeans_updatecc(ImageType4DF::Pointer dataPtr,
		    ImageType3DI::Pointer maskPtr,
		    ImageType3DU::Pointer labelPtr,
		    std::vector<FeatureType> & cc)
{
     IteratorType3DU labelIt(labelPtr, labelPtr->GetLargestPossibleRegion());
     IteratorType3DI maskIt(maskPtr, maskPtr->GetLargestPossibleRegion());
     ImageType3DI::IndexType maskIdx;
     ImageType4DF::IndexType dataIdx;
     ImageType4DF::SizeType dataSize = dataPtr->GetLargestPossibleRegion().GetSize();

     // clear old values. Set to zero. 
     for (unsigned k = 0; k < cc.size(); k ++) {
	       cc[k].coord.Fill(0);
	       std::fill(cc[k].data.begin(), cc[k].data.end(), 0);
     }

     // to record the num of points in each cluster.
     std::vector<unsigned> n_pts(cc.size(), 0);
     for (maskIt.GoToBegin(), labelIt.GoToBegin(); !labelIt.IsAtEnd();++labelIt, ++maskIt) {
	  if (maskIt.Get() > 0) {
	       unsigned k = labelIt.Get();
	       maskIdx = maskIt.GetIndex();
	       cc[k].coord[0] += maskIdx[0];
	       cc[k].coord[1] += maskIdx[1];
	       cc[k].coord[2] += maskIdx[2];
	       dataIdx[0] = maskIdx[0];
	       dataIdx[1] = maskIdx[1];
	       dataIdx[2] = maskIdx[2];
	       for (dataIdx[3] = 0; dataIdx[3] < dataSize[3]; dataIdx[3] ++) {
		    cc[k].data[dataIdx[3]] += dataPtr->GetPixel(dataIdx);
	       }
	       n_pts[k] ++;
	  } // in mask.
     }

     // compute mean from sum
     for (unsigned k = 0; k < cc.size(); k ++) {
	  cc[k].coord[0] /= n_pts[k];
	  cc[k].coord[1] /= n_pts[k];
	  cc[k].coord[2] /= n_pts[k];
	  for (unsigned p = 0; p < dataSize[3]; p ++) {
	       cc[k].data[p] /= n_pts[k];
	  }
     }

     return 0;
}


int compute_dist(FeatureType p1, FeatureType p2, double patch_size, double compact)
{
     double d_s = sqrt(pow(p1.coord[0]-p2.coord[0], 2) + pow(p1.coord[1]-p2.coord[1],2) + pow(p1.coord[2]-p2.coord[2],2));
     double d_c = 0;
     for (unsigned p = 0; p < p1.data.size(); p ++) {
	  d_c = d_c + pow(p1.data[p]-p2.data[p], 2);
     }
     d_c = sqrt(d_c);
     
     return sqrt(d_c * d_c + pow(d_s/patch_size, 2) * pow(compact,2));

}


int save_label_map(ImageType3DU::Pointer labelPtr,	    
		   ImageType3DI::Pointer maskPtr,
		   std::string filename)
{
     // create a output label map (1-based).
     ImageType3DU::RegionType outRegion = maskPtr->GetLargestPossibleRegion();
     ImageType3DU::Pointer outPtr = ImageType3DU::New();
     outPtr->SetRegions(outRegion);
     outPtr->Allocate();
     outPtr->FillBuffer(0);

     IteratorType3DU labelIt(labelPtr, labelPtr->GetLargestPossibleRegion());
     IteratorType3DI maskIt(maskPtr, maskPtr->GetLargestPossibleRegion());
     IteratorType3DU outIt(outPtr, outPtr->GetLargestPossibleRegion());

     for (maskIt.GoToBegin(), outIt.GoToBegin(), labelIt.GoToBegin(); !outIt.IsAtEnd();++outIt, ++maskIt, ++labelIt) {
	  if (maskIt.Get() > 0) {
	       outIt.Set(labelIt.Get() + 1);
	  }
     }

     WriterType3DU::Pointer writer = WriterType3DU::New();
	  
     writer->SetInput(outPtr);
     writer->SetFileName(filename);
     try 
     { 
	  writer->Update(); 
     } 
     catch( itk::ExceptionObject & err ) 
     { 
	  std::cerr << "ExceptionObject caught !" << std::endl; 
	  std::cerr << err << std::endl; 
	  return EXIT_FAILURE;
     } 

     std::cout << "save_label_map(): File " << filename << " saved.\n";

     return 0;
}


int build_edge(ImageType4DF::Pointer dataPtr,
	       ImageType3DI::Pointer maskPtr,
	       ImageType3DF::Pointer edgePtr,
	       std::vector<FeatureType> & cc,
	       const SLICParType & par)
{
     ImageType4DF::SizeType dataSize = dataPtr->GetLargestPossibleRegion().GetSize();
     // make sure the sum works.
     edgePtr->SetOrigin( maskPtr->GetOrigin() );
     edgePtr->SetSpacing(maskPtr->GetSpacing() );
     edgePtr->SetDirection(maskPtr->GetDirection() );

     // extract 3d vol from 4d.
     ImageType4DF::IndexType vol_idx;
     vol_idx.Fill(0);
     ImageType4DF::SizeType vol_size = dataSize;
     vol_size[3] = 0;

     // for each channel
     typedef itk::ExtractImageFilter<ImageType4DF, ImageType3DF> ExtFilter;
     typedef itk::CannyEdgeDetectionImageFilter <ImageType3DF, ImageType3DF>  CanFilter;
     typedef itk::AddImageFilter <ImageType3DF, ImageType3DF >  AddFilter;
     for (unsigned p = 0; p < dataSize[3]; p ++) {
	  vol_idx.Fill(0);
	  vol_idx[3] = p;
	  ImageType4DF::RegionType vol_region(vol_idx, vol_size);
	  ExtFilter::Pointer ext_filter = ExtFilter::New();
	  ext_filter->SetExtractionRegion(vol_region);
	  ext_filter->SetInput(dataPtr);
	  // ext_filter->SetDirectionCollapseToIdentity();
	  ext_filter->Update();
	  
	  // detect edges.  Canny is better.
	  CanFilter::Pointer can_filter = CanFilter::New();
	  can_filter->SetInput(ext_filter->GetOutput() );
	  can_filter->SetVariance(par.var);
	  can_filter->SetUpperThreshold(par.upper_th);
	  can_filter->SetLowerThreshold(par.lower_th);

	  save_image(can_filter->GetOutput(), "edge" + boost::lexical_cast<std::string>(p) + ".nii.gz" );     

	  // add to edge image.
	  AddFilter::Pointer add_filter = AddFilter::New();
	  add_filter->SetInput1(edgePtr);
	  add_filter->SetInput2(can_filter->GetOutput() );
	  add_filter->Update();
	  edgePtr = add_filter->GetOutput();
     }
     save_image(edgePtr, "edges.nii.gz");
}
